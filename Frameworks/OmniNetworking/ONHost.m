// Copyright 1997-2017 Omni Development, Inc. All rights reserved.
//
// This software may only be used and reproduced according to the
// terms in the file OmniSourceLicense.html, which should be
// distributed with this project and can also be found at
// <http://www.omnigroup.com/developer/sourcecode/sourcelicense/>.

#import <OmniNetworking/ONHost.h>

#import <Foundation/Foundation.h>
#import <SystemConfiguration/SystemConfiguration.h>
#import <OmniBase/OmniBase.h>
#import <OmniBase/system.h>

#import "ONHost-InternalAPI.h"
#import <OmniNetworking/ONHostAddress.h>
#import <OmniNetworking/ONPortAddress.h>
#import <OmniNetworking/ONServiceEntry.h>

RCS_ID("$Id$")

#ifndef MAX_HOSTNAME_LEN
#ifdef NI_MAXHOST
#define MAX_HOSTNAME_LEN NI_MAXHOST
#else
#define MAX_HOSTNAME_LEN 1024
#endif
#endif

@implementation ONHost
{
    NSString *hostname;
    NSString *canonicalHostname;
    NSArray *addresses;
    NSMutableDictionary *serviceAddresses;
    NSDate *expirationDate;
}

BOOL ONHostNameLookupDebug = NO;
static NSRecursiveLock *ONHostLookupLock;
static NSSet *squatterAddresses;
static NSTimeInterval ONHostDefaultTimeToLiveTimeInterval = 60.0 * 60.0;
static BOOL ONHostOnlyResolvesIPv4Addresses = NO; /* This doesn't actually have any effect on the network traffic generated by Apple's current lookupd. Sigh ... */

static enum {
    /* getaddrinfo() is threadable and versatile, but triggers a bug in the name servers used by a couple of high-profile websites whose names I will not mention here. */
    Resolver_getaddrinfo,
    /* Or, of course, we could just not look stuff up at all. */
    Resolver_none
} ONHostResolverAPI = Resolver_getaddrinfo;

/* The following variables are all protected by ONHostLookupLock */
static NSMutableDictionary *hostCache;
static NSString *domainName;
static NSString *localHostname;
static SCDynamicStoreRef systemConfigSession;
static CFRunLoopRef systemConfigListenerRunLoop;
static CFRunLoopSourceRef systemConfigNotificationSource;

/* These are used when we talk to configd */
static void systemConfigChanged(SCDynamicStoreRef, CFArrayRef, void *);
static void locked_connectToSysConfig(void);
static void locked_disconnectFromSysConfig(void);

+ (void)initialize;
{
    OBINITIALIZE;

    ONHostLookupLock = [[NSRecursiveLock alloc] init];
    hostCache = [[NSMutableDictionary alloc] initWithCapacity:16];

    localHostname = nil;
    domainName = nil;
    systemConfigSession = NULL;

    squatterAddresses = [[NSSet alloc] initWithObjects:
        [ONHostAddress addressWithIPv4UnsignedLong:0x405E6E0BUL],
        nil];
}

+ (void)setDebug:(BOOL)newDebugSetting;
{
    ONHostNameLookupDebug = newDebugSetting;
}

+ (void)setOnlyResolvesIPv4Addresses:(BOOL)onlyV4
{
    ONHostOnlyResolvesIPv4Addresses = onlyV4;
}

+ (BOOL)onlyResolvesIPv4Addresses
{
    return ONHostOnlyResolvesIPv4Addresses;
}

+ (void)setResolverType:(NSString *)resolverType
{
    if ([resolverType isEqualToString:@"getaddrinfo"])
        ONHostResolverAPI = Resolver_getaddrinfo;
    else if ([resolverType isEqualToString:@"none"])
        ONHostResolverAPI = Resolver_none;
    else {
        NSLog(@"Unknown resolver type \"%@\", not changed", resolverType);
    }
}


+ (void)listenForNetworkChanges;
{
    [ONHostLookupLock lock];

    if (systemConfigListenerRunLoop == NULL) {
        systemConfigListenerRunLoop = CFRunLoopGetCurrent();
        CFRetain(systemConfigListenerRunLoop);
        
        /* Clear out the cached info, because we don't know if it might have changed since we  cached it */
        systemConfigChanged(NULL, NULL, NULL);
    }

    [ONHostLookupLock unlock];
}

static void systemConfigChanged(SCDynamicStoreRef	store,
                                CFArrayRef		changedKeys,
                                void			*info)
{
    [ONHostLookupLock lock];
    if (ONHostNameLookupDebug)
        NSLog(@"%@Flushing cached host and domain names.", (store==NULL)?@"":@"Received change notification from configd. ");
    [domainName release];
    domainName = nil;
    [localHostname release];
    localHostname = nil;
    [ONHostLookupLock unlock];
}

static CFStringRef createDnsStateKey(void) CF_RETURNS_RETAINED;
static CFStringRef createDnsStateKey(void)
{
    return SCDynamicStoreKeyCreateNetworkGlobalEntity(NULL, kSCDynamicStoreDomainState, kSCEntNetDNS);
}

static void locked_connectToSysConfig(void)
{
    if (systemConfigSession == NULL) {
    
        if (ONHostNameLookupDebug)
            NSLog(@"Connecting to configd");
        
        /* Open a connection to configd */
        systemConfigSession = SCDynamicStoreCreate(NULL,
                                                   (CFStringRef)[[NSBundle bundleForClass:[ONHost class]] description],
                                                   systemConfigChanged,
                                                   NULL);
    }

    /* If we've been given a run loop, then register for notification of changes to the system configuration */
    if (systemConfigListenerRunLoop != NULL &&
        systemConfigNotificationSource == NULL &&
        systemConfigSession != NULL) {

        CFStringRef notificationKeys[2];
        CFArrayRef notificationArray;

        /* Indicate which configuration keys we're interested in */
        notificationKeys[0] = createDnsStateKey();
        notificationKeys[1] = SCDynamicStoreKeyCreateHostNames(NULL);
        notificationArray = CFArrayCreate(NULL, (const void **)notificationKeys, 2, &kCFTypeArrayCallBacks);
        CFRelease(notificationKeys[0]);
        CFRelease(notificationKeys[1]);

        if (ONHostNameLookupDebug)
            NSLog(@"Requesting notifications from configd, keys=%@", notificationArray);

        SCDynamicStoreSetNotificationKeys(systemConfigSession, notificationArray, NULL);
        CFRelease(notificationArray);

        /* Add a run loop source so we actually get called */
        systemConfigNotificationSource = SCDynamicStoreCreateRunLoopSource(NULL, systemConfigSession, 0);
        CFRunLoopAddSource(systemConfigListenerRunLoop, systemConfigNotificationSource, kCFRunLoopCommonModes);
    }
}

static void locked_disconnectFromSysConfig(void)
{
    if (systemConfigSession == NULL)
        return;

    if (systemConfigNotificationSource != NULL) {
        /* Don't disconnect if we're listening for changes. */
        return;
    }

    if (ONHostNameLookupDebug)
        NSLog(@"Disconnecting from configd.");

    CFRelease(systemConfigSession);
    systemConfigSession = NULL;
}

+ (NSString *)domainName;
{
    NSString *result;
    [ONHostLookupLock lock];
    if (domainName == nil) {
        CFDictionaryRef dnsSettings;
        CFStringRef dnsStateKey;
        
        locked_connectToSysConfig();

        dnsStateKey = createDnsStateKey();
        dnsSettings = SCDynamicStoreCopyValue(systemConfigSession, dnsStateKey);
        CFRelease(dnsStateKey);

        locked_disconnectFromSysConfig();

        domainName = (NSString *)CFDictionaryGetValue(dnsSettings, kSCPropNetDNSDomainName);
        [domainName retain];
        
        CFRelease(dnsSettings);
    }
    if (domainName == nil)
        domainName = [@"local" retain];
    result = [[domainName retain] autorelease];
    [ONHostLookupLock unlock];
    return result;
}

+ (NSString *)localHostname;
{
    NSString *result;
    [ONHostLookupLock lock];
    if (localHostname == nil) {
        locked_connectToSysConfig();
        localHostname = (NSString *)SCDynamicStoreCopyLocalHostName(systemConfigSession);
        locked_disconnectFromSysConfig();
    }
    if (localHostname == nil)
        localHostname = [@"localhost" retain];
    result = [[localHostname retain] autorelease];
    [ONHostLookupLock unlock];
    return result;
}

+ (id)_lockCache:(NSMutableDictionary *)hostInfoCache toCheckForKey:aCacheKey pendingLock:(NSLock **)pendingLockPtr
{
    id cachedObject;
    NSThread *currentThread = nil;
    NSLock *pendingLock;

    if (ONHostNameLookupDebug)
        currentThread = [NSThread currentThread];

    [ONHostLookupLock lock];

    do {
        cachedObject = [hostInfoCache objectForKey:aCacheKey];

        if (cachedObject == nil)
            break;

        if ([cachedObject isKindOfClass:[NSLock class]]) {
            pendingLock = (NSLock *)cachedObject;

            if (ONHostNameLookupDebug)
                NSLog(@"<%@> Lookup already in progress for %@.  Waiting for it to finish...", currentThread, [aCacheKey description]);

            [pendingLock retain];
            [ONHostLookupLock unlock];
            [pendingLock lock];
            [pendingLock unlock];
            [pendingLock release];

            if (ONHostNameLookupDebug)
                NSLog(@"<%@> Rechecking cache...", currentThread);

            // Now look again.
            [ONHostLookupLock lock];
            cachedObject = [hostInfoCache objectForKey:aCacheKey];
        } else if ([cachedObject isKindOfClass:[ONHost class]] && [(ONHost *)cachedObject isExpired]) {
                if (ONHostNameLookupDebug)
                    NSLog(@"<%@> Found an expired host in the cache (%@)", currentThread, cachedObject);
                [hostInfoCache removeObjectForKey:aCacheKey];
                cachedObject = nil;
        } else {
            if (ONHostNameLookupDebug)
                NSLog(@"<%@> Found a object in the cache (%@)", currentThread, cachedObject);
            [cachedObject retain];
            [ONHostLookupLock unlock];
            [cachedObject autorelease];
            return cachedObject;
        }
    } while (cachedObject != nil);

    // Not found in the cache, so we should look it up. Place an NSLock in the cache to allow other lookups of the same key to block until we've finished.
    pendingLock = [[NSLock alloc] init];
    [hostInfoCache setObject:pendingLock forKey:aCacheKey];
    [pendingLock lock];
    [ONHostLookupLock unlock];

    *pendingLockPtr = pendingLock;  // caller must release this
    return nil;
}

+ (ONHost *)hostForHostname:(NSString *)aHostname;
{
    ONHost *host;
    NSThread *currentThread = nil;
    NSLock *pendingLock;
    NSException *raisedException = nil;

    if (!aHostname)
	return nil;

    if (ONHostNameLookupDebug) {
        currentThread = [NSThread currentThread];
        NSLog(@"<%@> Starting name lookup for %@", currentThread, aHostname);
    }
        
    // First, check under the current capitalization of the address.  Since this is usually correct, this will avoid needlessly creating another string
    pendingLock = nil;
    host = [self _lockCache:hostCache toCheckForKey:aHostname pendingLock:&pendingLock];
    if (host == nil) {

        // Try the lowercase string
        NSString *lowercaseHostname = [aHostname lowercaseString];

        if (lowercaseHostname != aHostname && ![aHostname isEqualToString:lowercaseHostname]) {
            NSLock *oldPendingLock = pendingLock;
            pendingLock = nil;

            host = [self _lockCache:hostCache toCheckForKey:lowercaseHostname pendingLock:&pendingLock];

            [ONHostLookupLock lock];
            [hostCache removeObjectForKey:aHostname];  // remove oldPendingLock from the hostCache
            [oldPendingLock unlock];
            [oldPendingLock release];
            if (host)   // ... so that next time we won't need to call -lowercaseString ...
                [hostCache setObject:host forKey:aHostname];
            [ONHostLookupLock unlock];

            aHostname = lowercaseHostname;
        }
    }
    if (host != nil) {
        OBASSERT(pendingLock == nil);
        OBPOSTCONDITION([host isKindOfClass:[ONHost class]]);
        return host;
    }
    
    // There were either no previous attempts to determine the address for this host name or they failed.  We will unlock the main lock while we process the request so that others can get at the cache and possibly start their own request.  If another thread asks for the same host that we are currently resolving, though, they will need to block.  We will put an lock in the cache under the inquiry name for this purpose.
    OBASSERT(pendingLock != nil);

    // Do the lookup.  If there is an error we need to remove the pendingLock, unlock it and then reraise so that other threads may try the lookup (we don't cache failures).
    NS_DURING {
        host = [[self alloc] _initWithHostname:aHostname knownAddress:nil];
    } NS_HANDLER {
        OBASSERT(host == nil);
        raisedException = localException;
    } NS_ENDHANDLER;

    // Lock the cache again now that we have our result (or error)
    [ONHostLookupLock lock];

    if (host)
        [hostCache setObject:host forKey:aHostname];
    else
        [hostCache removeObjectForKey:aHostname];

    // Unlock the pending lock and the main lock
    [pendingLock unlock];
    [pendingLock release];
    [ONHostLookupLock unlock];

    if (raisedException)
        [raisedException raise];

    return [host autorelease];
}

+ (ONHost *)hostForAddress:(ONHostAddress *)anAddress;
{
    ONHost *host;
    NSException *failureException;
    NSLock *pendingOperationLock;
    struct sockaddr *portAddress;
    int err;
    char hostnameBuffer[MAX_HOSTNAME_LEN];
    
    if (!anAddress)
        return nil;

    if (ONHostNameLookupDebug)
        NSLog(@"<%@> Starting byaddress lookup for %@", [NSThread currentThread], [anAddress description]);

    // First, check the cache.
    pendingOperationLock = nil;
    host = [self _lockCache:hostCache toCheckForKey:anAddress pendingLock:&pendingOperationLock];
    if (host) {
        OBASSERT([host isKindOfClass:[ONHost class]]);
        OBASSERT(pendingOperationLock == nil);
        return host;
    }
    OBASSERT(pendingOperationLock != nil);
    
    // Now we do the actual lookup.

    if (ONHostNameLookupDebug)
        NSLog(@"<%@> Calling getnameinfo([%@], ..., NI_NAMEREQD)", [NSThread currentThread], [anAddress description]);

    @try {
    failureException = nil;

    portAddress = [anAddress mallocSockaddrWithPort:0];
    err = getnameinfo(portAddress, portAddress->sa_len,
                      hostnameBuffer, MAX_HOSTNAME_LEN,
                      NULL, 0,
                      NI_NAMEREQD);
    free(portAddress);

    switch (err) {
        case 0:
            // Success --- we got a hostname for this address. Look up the rest of the information about the host.
            @try {
                host = [self hostForHostname:[NSString stringWithUTF8String:hostnameBuffer]];
                // Only accept the host if it actually does refer to the IP address we started with.
                if ([[host addresses] indexOfObject:anAddress] == NSNotFound)
                    host = nil;
            } @catch (NSException *lookupException) {
                // Forward resolution failed for some reason, but that's OK really.
                host = nil;
                if (ONHostNameLookupDebug)
                    NSLog(@"<%@> Forward resolution failed: %@", [NSThread currentThread], lookupException);
            }
            if (host != nil)
                break;  // If we got a host we like, accept it.
            // Else, fall through.
        case EAI_NONAME:
            // Couldn't find a good hostname for this address. Create an unnamed ONHost.
            host = [[[self alloc] _initWithHostname:nil knownAddress:anAddress] autorelease];
            break;
        default:
            failureException = [self _exceptionForExtendedHostErrorNumber:err hostname:[anAddress description]];
    }
    } @catch (NSException *exc) {
        failureException = exc;
        host = nil;
    }
    
    // Place our result in the cache.
    [ONHostLookupLock lock];
    if (host)
        [hostCache setObject:host forKey:anAddress];
    else
        [hostCache removeObjectForKey:anAddress];
    [pendingOperationLock unlock];
    [pendingOperationLock release];
    [ONHostLookupLock unlock];

    // And finally, return the result to the caller.
    if (failureException) {
        [failureException raise];
        return nil; // pacify the compiler
    } else
        return host;
}

+ (NSString *)IDNEncodedHostname:(NSString *)aHostname;
{
    if ([aHostname canBeConvertedToEncoding:NSASCIIStringEncoding])
        return aHostname;

    NSArray *parts = [aHostname componentsSeparatedByString:@"."];
    NSMutableArray *encodedParts = [NSMutableArray array];
    NSUInteger partIndex, partCount = [parts count];

    for (partIndex = 0; partIndex < partCount; partIndex++)
        [encodedParts addObject:[self _punycodeEncode:[[parts objectAtIndex:partIndex] precomposedStringWithCompatibilityMapping]]];
    return [encodedParts componentsJoinedByString:@"."];
}

+ (NSString *)IDNDecodedHostname:(NSString *)anIDNHostname;
{
    NSArray *labels = [anIDNHostname componentsSeparatedByString:@"."];
    NSMutableArray *decodedLabels;
    NSUInteger labelIndex, labelCount;
    BOOL wasEncoded;
    
    labelCount = [labels count];
    decodedLabels = [[NSMutableArray alloc] initWithCapacity:labelCount];
    wasEncoded = NO;
    
    for (labelIndex = 0; labelIndex < labelCount; labelIndex++) {
        NSString *label, *decodedLabel;
        
        label = [labels objectAtIndex:labelIndex];
        decodedLabel = [self _punycodeDecode:label];
        if (!wasEncoded && ![label isEqualToString:decodedLabel])
            wasEncoded = YES;
        [decodedLabels addObject:decodedLabel];
    }
    
    if (wasEncoded) {
        NSString *result = [decodedLabels componentsJoinedByString:@"."];
        [decodedLabels release];
        return result;
    } else {
        /* This is by far the most common case. */
        [decodedLabels release];
        return anIDNHostname;
    }
}

+ (void)flushCache;
{
    NSArray *hostnames;
    NSUInteger hostnameIndex, hostnameCount;

    [ONHostLookupLock lock];
    NS_DURING {
        if (ONHostNameLookupDebug)
            NSLog(@"<%@> Flushing host cache", [NSThread currentThread]);
        hostnames = [[hostCache keyEnumerator] allObjects];
        hostnameCount = [hostnames count];
        for (hostnameIndex = 0; hostnameIndex < hostnameCount; hostnameIndex++) {
            NSString *aHostname;
            ONHost *host;

            aHostname = [hostnames objectAtIndex:hostnameIndex];
            host = [hostCache objectForKey:aHostname];
            if ([host isKindOfClass:self]) {
                // Only remove the ONHost entries, not the pending locks
                [hostCache removeObjectForKey:aHostname];
            }
        }
    } NS_HANDLER {
        NSLog(@"+[ONHost flushCache]: Warning: %@", [localException reason]);
    } NS_ENDHANDLER;
    [ONHostLookupLock unlock];
}

+ (void)setDefaultTimeToLiveTimeInterval:(NSTimeInterval)newValue;
{
    ONHostDefaultTimeToLiveTimeInterval = newValue;
    [self flushCache];
}

- (void)dealloc;
{
    [hostname release];
    [canonicalHostname release];
    [addresses release];
    [expirationDate release];
    [super dealloc];
}

- (NSString *)hostname;
{
    return hostname;
}

- (NSArray *)addresses;
{
    return addresses;
}

- (NSString *)canonicalHostname;
{
    if (canonicalHostname != nil)
        return canonicalHostname;
    
    if ([addresses count] == 1)
        return [[addresses objectAtIndex:0] description];

    return nil;
}

- (NSString *)IDNEncodedHostname;
{
    return [[self class] IDNEncodedHostname:hostname];
}


- (NSString *)domainName;
{
    NSRange dotRange;

    if (canonicalHostname == nil)
        return nil;
        
    dotRange = [canonicalHostname rangeOfString:@"." options:NSLiteralSearch];
    if (dotRange.length == 0)
        return nil;
    return [canonicalHostname substringFromIndex:NSMaxRange(dotRange)];
}

- (BOOL)isLocalHost;
{
    // quick test
    if ([[self addresses] containsObject:[ONHostAddress loopbackAddress]])
        return YES;

    // TODO: check against [[ONInterface interfaces] addresses]
    return NO;
}

- (void)flushFromHostCache;
{
    [ONHostLookupLock lock];
    NS_DURING {
        if ([hostCache objectForKey:hostname] == self)
            [hostCache removeObjectForKey:hostname];
    } NS_HANDLER {
        NSLog(@"+[ONHost removeFromHostCache]: Warning: %@", [localException reason]);
    } NS_ENDHANDLER;
    [ONHostLookupLock unlock];
}

// Looking up service addresses

- (NSArray *)portAddressesForService:(ONServiceEntry *)servEntry
{
    const char *myHostname, *myServname;
    struct addrinfo hints;
    struct addrinfo *results, *result;
    NSLock *operationLock;
    NSArray *portAddresses;
    NSException *failure;
    int err;

    operationLock = nil;
    portAddresses = [[self class] _lockCache:serviceAddresses toCheckForKey:servEntry pendingLock:&operationLock];
    if (portAddresses != nil) {
        OBASSERT([portAddresses isKindOfClass:[NSArray class]]);
        OBASSERT(operationLock == nil);
        return portAddresses;
    }
    OBASSERT(operationLock != nil);

    myHostname = [[self IDNEncodedHostname] UTF8String]; // The result should be ASCII, but -UTF8String is a superset and there is no ASCII variant.
    myServname = [[servEntry serviceName] UTF8String];
    bzero(&hints, sizeof(hints));
    hints.ai_flags = AI_DEFAULT;
    results = NULL;
    
    if ([[servEntry protocolName] isEqualToString:ONServiceEntryTCPProtocolName])
        hints.ai_protocol = IPPROTO_TCP;
    else if ([[servEntry protocolName] isEqualToString:ONServiceEntryUDPProtocolName])
        hints.ai_protocol = IPPROTO_UDP;

    err = getaddrinfo(myHostname, myServname, &hints, &results);
    if (err == 0) {
        NSMutableArray *addressBuf;
        
        addressBuf = [[NSMutableArray alloc] init];
        for(result = results; result != NULL; result = result->ai_next) {
            ONPortAddress *address;

            address = [[ONPortAddress alloc] initWithSocketAddress:result->ai_addr];
            if (address != nil) {
                [addressBuf addObject:address];
                [address release];
            }
        }
        freeaddrinfo(results);

        portAddresses = [[NSArray alloc] initWithArray:addressBuf];
        [addressBuf release];
        failure = nil;
    } else {
        failure = [[self class] _exceptionForExtendedHostErrorNumber:err hostname:[NSString stringWithFormat:@"%@:%@/%@", hostname, [servEntry serviceName], [servEntry protocolName]]];
        portAddresses = nil;
    }

    // Place our result in the cache.
    [ONHostLookupLock lock];
    if (portAddresses)
        [serviceAddresses setObject:portAddresses forKey:servEntry];
    else
        [serviceAddresses removeObjectForKey:servEntry];
    [operationLock unlock];
    [operationLock release];
    [ONHostLookupLock unlock];

    // And finally, return the result to the caller.
    if (failure) {
        OBASSERT(portAddresses == nil);
        [failure raise];
        [portAddresses release]; // make clang happy
        return nil; // pacify the compiler
    } else
        return [portAddresses autorelease];
}

// Debugging

- (NSMutableDictionary *)debugDictionary;
{
    NSMutableDictionary *debugDictionary;

    debugDictionary = [super debugDictionary];
    if (addresses)
        [debugDictionary setObject:addresses forKey:@"addresses"];
    if (hostname)
        [debugDictionary setObject:hostname forKey:@"hostname"];
    if (expirationDate)
        [debugDictionary setObject:expirationDate forKey:@"expirationDate"];
    return debugDictionary;
}

#pragma mark - Internal

+ (void)_raiseExceptionForHostErrorNumber:(int)hostErrorNumber hostname:(NSString *)aHostname;
{
    NSBundle *myBundle = [NSBundle bundleForClass:[ONHost class]];
    
    switch (hostErrorNumber) {
        case HOST_NOT_FOUND:
            [NSException raise:ONHostNotFoundExceptionName format:NSLocalizedStringFromTableInBundle(@"No such host %@", @"OmniNetworking", myBundle, @"gethostbyname error - HOST_NOT_FOUND - 'No such host is known.'"), aHostname];
            break;
        case TRY_AGAIN:
            [NSException raise:ONHostNotFoundExceptionName format:NSLocalizedStringFromTableInBundle(@"Temporary error looking up host %@, try again", @"OmniNetworking", myBundle, @"gethostbyname error - TRY_AGAIN - 'This  is  usually a temporary error and means that the local server did not  receive  a  response  from  an authoritative server.  A  retry  at some later time may succeed.'"), aHostname];
            break;
        case NO_RECOVERY:
            [NSException raise:ONHostNotFoundExceptionName format:NSLocalizedStringFromTableInBundle(@"Unexpected server failure looking up host %@", @"OmniNetworking", myBundle, @"gethostbyname error - NO_RECOVERY - 'Some  unexpected server failure was encountered.  This is a  non-recoverable error.'"), aHostname];
            break;
        case NO_DATA:
            [NSException raise:ONHostHasNoAddressesExceptionName format:NSLocalizedStringFromTableInBundle(@"Found no addresses for host %@", @"OmniNetworking", myBundle, @"gethostbyname error - NO_DATA - 'The  requested  name  is  valid but does not have an IP  address;  this is  not  a  temporary  error.  This means that the name is known to the name server but there is no address associated with this name.'"), aHostname];
            break;
        default:
            [NSException raise:ONHostNameLookupErrorExceptionName format:NSLocalizedStringFromTableInBundle(@"Error looking up host %@", @"OmniNetworking", myBundle, @"gethostbyname error - other errors - specific cause of error is not known"), aHostname];
            break;
    }
}

+ (NSException *)_exceptionForExtendedHostErrorNumber:(int)eaiError hostname:(NSString *)name
{
    NSBundle *myBundle = [NSBundle bundleForClass:[ONHost class]];
    NSString *exceptionName, *exceptionReason;
    NSDictionary *userInfo;

    userInfo = NULL;
    
    switch(eaiError) {
        // Temporary name lookup failure.
        case EAI_AGAIN:
            exceptionName = ONHostNotFoundExceptionName;
            exceptionReason = [NSString stringWithFormat:NSLocalizedStringFromTableInBundle(@"Temporary error looking up host %@, try again", @"OmniNetworking", myBundle, @"getaddrinfo error - EAI_AGAIN - 'This  is  usually a temporary error and means that the local server did not  receive  a  response  from  an authoritative server.  A  retry  at some later time may succeed.'"), name];
            break;

        // These are the "success, but no success" errors...
        case EAI_NONAME:
            exceptionName = ONHostHasNoAddressesExceptionName;
            exceptionReason = [NSString stringWithFormat:NSLocalizedStringFromTableInBundle(@"Found no hostname for  %@", @"OmniNetworking", myBundle, @"gethostbyname error - EAI_NONAME - The specified address is valid but does not have a corresponding hostname. This probably means that the address has no reverse DNS information."), name];
            break;
        case EAI_NODATA:
#warning EAI_NODATA seems to be used for both no-such-host and host-has-no-address cases. Is there a way to distinguish between the two when using getaddrinfo?
            exceptionName = ONHostHasNoAddressesExceptionName;
            exceptionReason = [NSString stringWithFormat:NSLocalizedStringFromTableInBundle(@"Found no address for host %@", @"OmniNetworking", myBundle, @"gethostbyname error - EAI_NODATA - The specified hostname is valid but does not have not have an IP  address; this is not a temporary error. This means that the name is known to the name server but there is no address associated with this name."), name];
            break;
        case EAI_ADDRFAMILY:
            exceptionName = ONHostHasNoAddressesExceptionName;
            exceptionReason = [NSString stringWithFormat:NSLocalizedStringFromTableInBundle(@"Found no appropriate addresses for host %@", @"OmniNetworking", myBundle, @"gethostbyname error - EAI_ADDRFAMILY - The specified name is valid but does not have an address we can use. This probably means it has an address of some other address family."), name];
            break;
            
        // Catchall for errors which probably indicate either something wrong with OmniNetworking, or something wrong with the system at a low enough level that we can't do anything about it. We use gai_strerror() to display the particular error in case that's useful for debugging.
        default:
            exceptionName = ONHostNameLookupErrorExceptionName;
            exceptionReason = [NSString stringWithFormat:NSLocalizedStringFromTableInBundle(@"Unexpected server failure (%d: %s) looking up host %@", @"OmniNetworking", myBundle, @"getaddrinfo error - miscellaneous unrecoverable or internal errors - bad parameter passed to get_info call or other unexpected problem"), eaiError, gai_strerror(eaiError), name];
            break;

        case EAI_SYSTEM:
            // Some system-level error occurred; error code is in errno
            exceptionName = ONHostNameLookupErrorExceptionName;
            exceptionReason = [NSString stringWithFormat:NSLocalizedStringFromTableInBundle(@"Error looking up host %@: %s", @"OmniNetworking", myBundle, @"getnameinfo or getaddrinfo error - EAI_SYSTEM - specific cause of error is not known"), name, strerror(OMNI_ERRNO())];
            userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:OMNI_ERRNO()] forKey:OBExceptionPosixErrorNumberKey];
            break;
    }

    return [NSException exceptionWithName:exceptionName
                                   reason:exceptionReason
                                 userInfo:userInfo];
}

- _initWithHostname:(NSString *)aHostname knownAddress:(ONHostAddress *)knownAddress;
{    
    if ([super init] == nil)
	return nil;

    if (aHostname == nil && knownAddress != nil) {
        hostname = [[knownAddress description] retain];
        addresses = [[NSArray arrayWithObject:knownAddress] retain];
        return self;
    }

    OBASSERT(aHostname != nil && knownAddress == nil);
    
    hostname = [aHostname retain];

    if ([self _tryLocalhost] || [self _tryToLookupHostInfoAsDottedQuad])
        return self;

    NS_DURING {
        switch(ONHostResolverAPI) {
            case Resolver_getaddrinfo:
                [self _lookupHostInfoUsingGetaddrinfo];
                break;
            default:
                addresses = [[NSArray alloc] init];
                break;
        }
    } NS_HANDLER {
        [self release];
        [localException raise];
    } NS_ENDHANDLER;
    if (expirationDate == nil)
        expirationDate = [[NSDate alloc] initWithTimeIntervalSinceNow:ONHostDefaultTimeToLiveTimeInterval];


    return self;
}

- (BOOL)isExpired;
{
    return [expirationDate timeIntervalSinceNow] < 0.0;
}

- (void)_lookupHostInfoUsingGetaddrinfo;
{
    const char *myHostname;
    struct addrinfo hints;
    struct addrinfo *results, *result;
    NSMutableArray *addressBuf;
    int err;

    OBPRECONDITION(addresses == nil);
    
    myHostname = [[self IDNEncodedHostname] UTF8String]; // The result should be ASCII, but -UTF8String is a superset and there is no ASCII variant.
    bzero(&hints, sizeof(hints));
    hints.ai_flags = AI_CANONNAME;
    results = NULL;
    
    if (ONHostOnlyResolvesIPv4Addresses)
        hints.ai_family = PF_INET;
    else
        hints.ai_family = PF_UNSPEC;

    err = getaddrinfo(myHostname, NULL, &hints, &results);
    if (err != 0) {
        [[[self class] _exceptionForExtendedHostErrorNumber:err hostname:hostname] raise];
    }

    if (results->ai_canonname != NULL) {
        // OBFinishPorting: Is this really ASCII or is it UTF-8 or some other encoding? Before this was using -initWithCString: which would likely have used Mac Roman.
        canonicalHostname = [[NSString alloc] initWithBytes:results->ai_canonname length:strlen(results->ai_canonname) encoding:NSASCIIStringEncoding];
    }

    addressBuf = [[NSMutableArray alloc] init];
    for(result = results; result != NULL; result = result->ai_next) {
        ONHostAddress *address = [ONHostAddress hostAddressWithSocketAddress:result->ai_addr];
        if (address != nil && ![squatterAddresses containsObject:address])
            [addressBuf addObject:address];
    }
    freeaddrinfo(results);

    addresses = [[NSArray alloc] initWithArray:addressBuf];
    [addressBuf release];
}

#pragma mark - Private

// Punycode is defined in RFC 3492

#define ACEPrefix @"xn--"   // Prefix for encoded labels, defined in RFC3490 [5]

#define encode_character(c) (c) < 26 ? (c) + 'a' : (c) - 26 + '0'

static const short punycodeDigitValue[0x7B] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 0x00 - 0x0F
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 0x10 - 0x1F
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 0x20 - 0x2F
    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1, -1, // 0x30 - 0x3F
    -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 0x40 - 0x4F
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, // 0x50 - 0x5F
    -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 0x60 - 0x6F
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25                      // 0x70 - 0x7A
};


static int adaptPunycodeDelta(int delta, int number, BOOL firstTime)
{
    int power;
    
    delta = firstTime ? delta / 700 : delta / 2;
    delta += delta / number;
    
    for (power = 0; delta > (35 * 26) / 2; power += 36)
        delta /= 35;
    return power + (35 + 1) * delta / (delta + 38);
}

/* Minimal validity checking. This should be elaborated to include the full IDN stringprep profile. */
static BOOL validIDNCodeValue(unsigned codepoint)
{
    /* Valid Unicode, non-basic codepoint? (implied by rfc3492) */
    if (codepoint < 0x9F || codepoint > 0x10FFFF)
        return NO;
    
    /* Some prohibited values from rfc3454 referenced by rfc3491[5] */
    if (codepoint == 0x00A0 ||
        (codepoint >= 0x2000 && codepoint <= 0x200D) ||
        codepoint == 0x202F || codepoint == 0xFEFF ||
        ( codepoint >= 0xFFF9 && codepoint <= 0xFFFF ))
        return NO; /* Miscellaneous whitespace & non-printing characters */
    
    int plane = ( codepoint & ~(0xFFFF) );

    if (plane == 0x0F0000 || plane == 0x100000 ||
        (codepoint >= 0xE000 && codepoint <= 0xF8FF))
        return NO;  /* Private use areas */
        
    if ((codepoint & 0xFFFE) == 0xFFFE ||
        (codepoint >= 0xD800 && codepoint <= 0xDFFF) ||
        (codepoint >= 0xFDD0 && codepoint <= 0xFDEF))
        return NO; /* Various non-character code points */
    
    /* end of gauntlet */
    return YES;
}

+ (NSString *)_punycodeEncode:(NSString *)aString;
{
    // setup buffers
    char outputBuffer[MAX_HOSTNAME_LEN]; 
    size_t stringLength = [aString length];
    unichar *inputBuffer = alloca(stringLength * sizeof(unichar));
    unichar *inputPtr, *inputEnd = inputBuffer + stringLength;
    char *outputEnd = outputBuffer + MAX_HOSTNAME_LEN;
    char *outputPtr = outputBuffer;
    
    // check once for hostname too long here and just refuse to encode if it is (this handles it if all ASCII)
    // there are additional checks for running over the buffer during the encoding loop
    if (stringLength > MAX_HOSTNAME_LEN)
        return aString;
    
    [aString getCharacters:inputBuffer];
    
    // handle ASCII characters
    for (inputPtr = inputBuffer; inputPtr < inputEnd; inputPtr++) {
        if (*inputPtr < 0x80) 
            *outputPtr++ = *inputPtr;            
    }
    unsigned int handled = (unsigned int)(outputPtr - outputBuffer);
    
    if (handled == stringLength)
        return aString;
    
    // add dash separator
    if (handled > 0 && outputPtr < outputEnd)
        *outputPtr++ = '-';
    
    // encode the rest
    int n = 0x80;
    int delta = 0;
    int bias = 72;
    BOOL firstTime = YES;
    
    while (handled < stringLength) {
        unichar max = (unichar)-1;
        for (inputPtr = inputBuffer; inputPtr < inputEnd; inputPtr++) {
            if (*inputPtr >= n && *inputPtr < max)
                max = *inputPtr;
        }
        
        delta += (max - n) * (handled + 1);
        n = max;
                
        for (inputPtr = inputBuffer; inputPtr < inputEnd; inputPtr++) {
            if (*inputPtr < n) 
                delta++;
            else if (*inputPtr == n) {
                int oldDelta = delta;
                int power = 36;
                
                // NSLog(@"encode: delta=%d pos=%d bias=%d codepoint=%05x", delta, inputPtr-inputBuffer, bias, *inputPtr);
                
                while (1) {
                    int t;
                    if (power <= bias)
                        t = 1;
                    else if (power >= bias + 26)
                        t = 26;
                    else
                        t = power - bias;
                    if (delta < t)
                        break;
                    if (outputPtr >= outputEnd)
                        return aString;
                    *outputPtr++ = encode_character(t + (delta - t) % (36 - t));
                    delta = (delta - t) / (36 - t);
                    power += 36;
		}
                
                if (outputPtr >= outputEnd)
                    return aString;
                *outputPtr++ = encode_character(delta);
                bias = adaptPunycodeDelta(oldDelta, ++handled, firstTime);
                firstTime = NO;
                delta = 0;
	    }
	}
        delta++;
        n++;
    }
    if (outputPtr >= outputEnd)
        return aString;
    *outputPtr = '\0';
#ifdef DEBUG_toon    
    NSLog(@"Punycode encoded \"%@\" into \"%s\"", aString, outputBuffer);
#endif    
    return [ACEPrefix stringByAppendingString:[NSString stringWithUTF8String:outputBuffer]];
}

+ (NSString *)_punycodeDecode:(NSString *)aString;
{
    NSMutableString *decoded;
    NSRange deltas;
    unsigned int *delta;
    unsigned deltaCount, deltaIndex;
    NSUInteger labelLength;
    const unsigned acePrefixLength = 4;
        
    /* Check that the string has the IDNA ACE prefix. Most strings won't. */
    labelLength = [aString length];
    OBASSERT([ACEPrefix length] == acePrefixLength);
    if (labelLength < acePrefixLength ||
        ([aString compare:ACEPrefix options:NSCaseInsensitiveSearch range:(NSRange){0,acePrefixLength}] != NSOrderedSame))
        return aString;
    
    /* Also, any valid encoded string will be all-ASCII */
    if (![aString canBeConvertedToEncoding:NSASCIIStringEncoding])
        return aString;
    
    /* Find the delimiter that marks the end of the basic-code-points section. */
    NSRange delimiter = [aString rangeOfString:@"-"
                                       options:NSBackwardsSearch
                                         range:(NSRange){acePrefixLength, labelLength-acePrefixLength}];
    if (delimiter.length > 0) {
        decoded = [[aString substringWithRange:(NSRange){acePrefixLength, delimiter.location - acePrefixLength}] mutableCopy];
        deltas = (NSRange){NSMaxRange(delimiter), labelLength - NSMaxRange(delimiter)};
    } else {
        /* No delimiter means no basic code point section: it's all encoded deltas (RFC3492 [3.1]) */
        decoded = [[NSMutableString alloc] init];
        deltas = (NSRange){acePrefixLength, labelLength - acePrefixLength};
    }
    
    /* If there aren't any deltas, it's not a valid IDN label, because you're not supposed to encode something that didn't need to be encoded. */
    if (deltas.length == 0) {
        [decoded release];
        return aString;
    }
    
    unsigned int decodedLabelLength = (unsigned)[decoded length];
    
    /* Convert the variable-length-integers in the deltas section into machine representation */
    {
        unichar *enc;
        unsigned i, bias, value, weight, position;
        BOOL reset;
        const int base = 36, tmin = 1, tmax = 26;
        
        enc = malloc(sizeof(*enc) * deltas.length);  // code points from encoded string
        delta = malloc(sizeof(*delta) * deltas.length); // upper bound on number of decoded integers
        deltaCount = 0;
        bias = 72;
        reset = YES;
        value = weight = position = 0;
                
        [aString getCharacters:enc range:deltas];
        for(i = 0; i < deltas.length; i++) {
            int digit, threshold;
            
            if (reset) {
                value = 0;
                weight = 1;
                position = 0;
                reset = NO;
            }
            
            if (enc[i] <= 0x7A)
                digit = punycodeDigitValue[enc[i]];
            else {
                free(enc);
                goto fail;
            }
            if (digit < 0) { // unassigned value
                free(enc);
                goto fail;
            }
            
            value += weight * digit;
            threshold = base * (position+1) - bias;
            
            // clamp to tmin=1 tmax=26 (rfc3492 [5])
            threshold = MIN(threshold, tmax);
            threshold = MAX(threshold, tmin);
            
            if (digit < threshold) {
                delta[deltaCount++] = value;
                // NSLog(@"decode: delta[%d]=%d bias=%d from=%@", deltaCount-1, value, bias, [aString substringWithRange:(NSRange){deltas.location + i - position, position+1}]);
                bias = adaptPunycodeDelta(value, deltaCount + decodedLabelLength, (deltaCount==1) ? YES : NO);
                reset = YES;
            } else {
                weight *= (base - threshold);
                position ++;
            }
        }
        
        free(enc);
        
        if (!reset) {
            /* The deltas section ended in the middle of an integer: something's wrong */
            goto fail;
        }
        
        /* deltas[] now holds deltaCount integers */
    }

    /* now use the decoded integers to insert characters into the decoded string */
    {
        unsigned position, codeValue;
        unichar ch[1];
        
        position = 0;
        codeValue = 0x80;
        
        for (deltaIndex = 0; deltaIndex < deltaCount; deltaIndex ++) {
            position += delta[deltaIndex];

            codeValue += ( position / (decodedLabelLength + 1) );
            position = ( position % (decodedLabelLength + 1) );
            
            if (!validIDNCodeValue(codeValue))
                goto fail;
            
            /* TODO: This will misbehave for code points greater than 0x0FFFF, because NSString uses a 16-bit encoding internally; the position values will be off by one afterwards [actually, we'll just get bad results because I'm using initWithCharacters:length: (BMP-only) instead of initWithCharacter: (all planes but only exists in OmniFoundation)] */
            ch[0] = codeValue;
            NSString *insertion = [[NSString alloc] initWithCharacters:ch length:1];
            [decoded replaceCharactersInRange:(NSRange){position, 0} withString:insertion];
            [insertion release];
            
            position ++;
            decodedLabelLength ++;
        }
    }
    
    if ([decoded length] != decodedLabelLength)
        goto fail;
    
    free(delta);
    
    NSString *normalized = [decoded precomposedStringWithCompatibilityMapping];  // Applies normalization KC
    if ([normalized compare:decoded options:NSLiteralSearch] != NSOrderedSame) {
        // Decoded string was not normalized, therefore could not have been the result of decoding a correctly encoded IDN.
        [decoded release];
        return aString;
    } else {
        [decoded autorelease];
        return normalized;
    }
    
fail:
    free(delta);
    [decoded release];
    return aString;
}

- (BOOL)_tryLocalhost;
    // Make sure localhost works even when the system is misconfigured.
{
    OBPRECONDITION(addresses == nil);
    
    if ([hostname caseInsensitiveCompare:@"localhost"] != NSOrderedSame)
        return NO;

    canonicalHostname = [@"localhost" retain];
    addresses = [[NSArray arrayWithObject:[ONHostAddress loopbackAddress]] retain];
    return YES;
}

- (BOOL)_tryToLookupHostInfoAsDottedQuad;
{
    ONHostAddress *address;

    OBPRECONDITION(addresses == nil);
    
    address = [ONHostAddress hostAddressWithNumericString:hostname];
    if (address == nil)
        return NO;

    // Oh ho!  They gave us an IP number in dotted quad notation!  I guess we'll return the dotted quad as the canonical hostname (computed in -canonicalHostname), and the converted address as the address.
    // (We're not calculating the real canonical hostname because it might return more addresses, and that wouldn't be what the user wants since they specifically specified a single address.)
    canonicalHostname = nil;
    addresses = [[NSArray arrayWithObject:address] retain];
    return YES;
}

@end

NSString * const ONHostNotFoundExceptionName = @"ONHostNotFoundExceptionName";
NSString * const ONHostNameLookupErrorExceptionName = @"ONHostNameLookupErrorExceptionName";
NSString * const ONHostHasNoAddressesExceptionName = @"ONHostHasNoAddressesExceptionName";
