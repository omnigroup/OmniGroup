#!/usr/bin/ruby
#
# Copyright 2010-2012 Omni Development, Inc. All rights reserved.
#
# This software may only be used and reproduced according to the
# terms in the file OmniSourceLicense.html, which should be
# distributed with this project and can also be found at
# <http://www.omnigroup.com/developer/sourcecode/sourcelicense/>.
#
# $Id$

# Very minimal class for getting informtion out of an Xcode xcodeproj file

gem_path = Pathname.new(File.dirname(__FILE__) + "/plist-3.1.0/lib").realpath.to_s
$: << gem_path
require 'plist'

module Xcode
end

class Xcode::Project
    attr_reader :path, :project, :root

    def initialize(path)
        @path = Pathname.new(path).realpath.to_s
        fail "#{path} is not a directory\n" unless File.directory?(@path)

        plist_file = path + "/project.pbxproj"
        fail "no project file in #{path}\n" unless File.exists?(plist_file)
        @project = Plist::parse_xml(`plutil -convert xml1 -o - "#{plist_file}"`)
        
        @objects = @project['objects']
        @root = @objects[@project['rootObject']]
        fail "doesn't look like the xcodeproj I expect\n" unless @root['isa'] == 'PBXProject'

        # Build map of object to containing group
        @containingGroup = {}
        @objects.each {|k,v|
            if ['PBXGroup', 'PBXVariantGroup'].index(v['isa'])
                v['children'].each {|ch|
                    @containingGroup[ch.to_s] = k;
                }
            end
        }
        @containingGroup[@root['mainGroup'].to_s] = @project['rootObject']

        # Build source tree map
        @sourceTrees = {'SOURCE_ROOT' => File.dirname(@path)}

    end

    # Return an object with the indicated key, optionally requiring it be one of the indicated classes
    def get(key, *allowedClasses)
        obj = @objects[key]
        fail "No object with id '#{key}'!" unless obj
        if allowedClasses
            actualClass = obj['isa']
            fail "Object '#{key}' is a '#{actualClass}', but expected one of #{allowedClasses.join(", ")}." unless allowedClasses.index(actualClass)
        end
        obj
    end


    def resolvepath(key)
        @pathCache ||= {}
        
        cached = @pathCache[key]
        return cached if cached

        obj = get(key, 'PBXFileReference', 'PBXVariantGroup', 'PBXGroup', 'PBXProject', 'PBXReferenceProxy')
        return @sourceTrees['SOURCE_ROOT'] if obj['isa'] == 'PBXProject'

        sourceTree = obj['sourceTree']

        case sourceTree
        when '<group>'
            groupID = @containingGroup[key.to_s]
            fail "no group contains child ref #{key}, died" unless groupID
            base = resolvepath(groupID)
        when '<absolute>'
            base = '/';
        when 'BUILT_PRODUCTS_DIR'
            base = ENV['BUILT_PRODUCTS_DIR']
            fail "BUILT_PRODUCTS_DIR not specified in environment, but referenced by found file" unless base
        else
            base = @sourceTrees[sourceTree.to_s]
            fail "Unsupported source tree #{sourceTree}" unless base
        end

        path = obj['path']
        if !path || path == ""
            path = base
        else
            path = "#{base}/#{path}"
        end

        @pathCache[key] = path
        return path;
    end

    def each_target(&block)
        @root['targets'].each {|targetID|
          target = get(targetID, 'PBXNativeTarget', 'PBXAggregateTarget', 'PBXLegacyTarget')
          block.call(target)
        }
    end
    
    # Calls a block for each build file in the target, passing the build file id, build file plist and file ref id and file ref plist
    # Might want to add more classes to make this less crazy
    def each_file_in_target(target, &block)
        target['buildPhases'].each {|phaseID|
          phase = get(phaseID, *%w[PBXCopyFilesBuildPhase PBXFrameworksBuildPhase PBXHeadersBuildPhase PBXResourcesBuildPhase PBXRezBuildPhase PBXShellScriptBuildPhase PBXSourcesBuildPhase])

          phase['files'].each {|buildFileID|
            buildFile = get(buildFileID, 'PBXBuildFile')
            fileRefID = buildFile['fileRef']
            #print "file " . $fileRef . "\n";
            
            # Products from other included projects are instances of PBXReferenceProxy (like a .a file generated by a dependency on another project)
            fileRef = get(fileRefID, 'PBXFileReference', 'PBXVariantGroup', 'PBXReferenceProxy', 'XCVersionGroup')
            if %w[PBXVariantGroup XCVersionGroup].index(fileRef['isa'])
              fileRef['children'].each {|childID|
                child = get(childID, 'PBXFileReference', 'PBXReferenceProxy')
                block.call(buildFileID, buildFile, childID, child)
              }
            else
              block.call(buildFileID, buildFile, fileRefID, fileRef)
            end
          }
        }
    end
    
    def build_file_has_attribute?(buildFile, attribute)
        fileSettings = buildFile['settings']
        fileAttributes = (fileSettings && fileSettings['ATTRIBUTES']) || [];
        return fileAttributes.index(attribute) != nil
    end
    
    def target_product_name(target)
        product_name = nil
        configuration_list = get(target['buildConfigurationList'], 'XCConfigurationList')
        configuration_list['buildConfigurations'].each {|configID|
            # We assume the product name isn't set in the base configuration. Probably isn't, but it *could* be set there.
            config = get(configID, 'XCBuildConfiguration')
            settings = config['buildSettings']
            configs_name = target['name']
            if settings
                configs_name = settings['PRODUCT_NAME'] || configs_name
            end
            
            if product_name.nil?
                product_name = configs_name
            else
                fail "Different configurations have different product names!" unless product_name == configs_name
            end
        }
        return product_name
    end
    
end
